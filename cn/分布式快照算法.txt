Flink作业可以抽象成有向图表示，图的顶点是算子（operator），边是数据流（data stream），与Chandy-Lamport算法提出的“进程-链路”图模型恰好对应。
存在的问题：
1. Flink作业的快照要包含两部分，即算子所处的状态以及数据流承载的数据。算子每收到/发出一条数据，以及数据流每流入/流出一条数据，都会造成全局状态的改变。
2. 算子可以感知到自己的状态，但数据流的状态不容易记录，主要是因为承载的数据量太大，并且总是在变化。
3. 时间是无法静止的（即数据总是在流动的），并且快照不能stop-the-world，否则会造成延迟和数据堆积，降低吞吐量。
解决的办法：
1. 每个算子自己记录的状态合并出全局快照。
2. 引入一个标记把数据流从时域上切分成段。
标记就是Flink的检查点屏障，由JobManager周期性的生成（周期长度由StreamExecutionEnvironment.enableCheckpointing()
方法来指定），并广播给所有的Source算子，沿着数据流传播下去。
下游算子如果检测到屏障的存在，就会触发快照动作，不必再关心时间无法静止的问题.
Flink Checkpoint的步骤如下：
1. JobManager的CheckPoint Coordiantor发出快照指令到TaskManager。
2. 所有的Source算子收到后，记录自己当前的offset状态，并将屏障广播到下游算子（沿着JobGraph传播）。
3. 下游非Source的算子要根据输入流的个数分别处理：
   1. 一个输入流，收到屏障后立即作快照。
   2. 多个输入流，收到屏障后会阻塞这个输入流，继续接收其他输入流，直到所有输入流的屏障都到达。一旦算子收齐了所有屏障，它就会生成自己状态的快照，并继续将屏障广播给下游所有数据流。算子解除对输入流的阻塞，继续进行计算。
   （阻塞的原因：避免将检查点n与检查点n + 1的数据混淆）
4. Sink算子接收到屏障之后会向JobManager确认，所有Sink都确认收到屏障标记着这一周期checkpoint过程结束，快照成功。


存储方式：
1.异步：算子收齐屏障并触发快照，不会等待快照数据全部写入状态后端，而是一边后台写入，一边立刻继续处理数据流，并将屏障发送到下游，实现了最小化延迟。
2.增量：只有RocksDB Backend支持增量写入的方式,

存储介质：
  Operator state 保存在机器节点本地。Flink 定期获取所有状态的快照，并将这些快照复制到持久化的位置，比如RocksDb。
 Flink的StateBackend有两种实现：
 1. 一种基于 RocksDB 内嵌 key/value 存储将其工作状态保存在磁盘上。
 2.一种基于堆的 state backend，将其工作状态保存在 Java 的堆内存中。
    FsStateBackend，将其状态快照持久化到分布式文件系统；
    MemoryStateBackend，它使用 JobManager 的堆保存状态快照。
